import numpy as np
import warnings
from scipy.optimize import minimize
from qiskit import QuantumCircuit, pulse
from qiskit.circuit import ParameterVector
from qiskit.quantum_info import SparsePauliOp
from qiskit.pulse import Gaussian, Drag, GaussianSquare
from qiskit_ibm_runtime.fake_provider import FakeManilaV2
from qiskit.primitives import BackendEstimatorV2

warnings.filterwarnings("ignore", category=DeprecationWarning)

backend = FakeManilaV2()
num_qubits = 2

hamiltonian = SparsePauliOp.from_list([
    ("II", -1.05237), ("IZ", 0.39793), ("ZI", -0.39793), ("ZZ", -0.01128), ("XX", 0.18093)
])

params = ParameterVector('Î¸', 4)
ansatz = QuantumCircuit(num_qubits)
ansatz.ry(params[0], 0)
ansatz.ry(params[1], 1)
ansatz.cz(0, 1)
ansatz.ry(params[2], 0)
ansatz.ry(params[3], 1)

def apply_hardware_pulses(circuit, backend):
    for i in range(num_qubits):
        with pulse.build(backend, name=f"ry_pulse") as ry_sched:
            drive_chan = pulse.drive_channel(i)
            pulse.play(Drag(duration=160, amp=0.1, sigma=40, beta=0.5), drive_chan)
        circuit.add_calibration('ry', [i], ry_sched)

    with pulse.build(backend, name="cz_pulse") as cz_sched:
        try:
            c_chan = pulse.control_channels(0, 1)[0]
        except:
            c_chan = pulse.drive_channel(0)
        pulse.play(GaussianSquare(duration=800, amp=0.15, sigma=64, width=600), c_chan)
    
    circuit.add_calibration('cz', [0, 1], cz_sched)
    return circuit

ansatz = apply_hardware_pulses(ansatz, backend)
estimator = BackendEstimatorV2(backend=backend)

def cost_function(params_values):
    pub = (ansatz, hamiltonian, [params_values])
    job = estimator.run([pub])
    result = job.result()[0]
    energy = result.data.evs[0]
    print(f"Energy: {energy:.4f}")
    return energy

initial_params = np.random.random(ansatz.num_parameters)
result = minimize(cost_function, initial_params, method='COBYLA', options={'maxiter': 10})

print(f"Final Pulse-Level VQE Energy: {result.fun}")
